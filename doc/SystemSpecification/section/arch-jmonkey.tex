\subsection{The jMonkeyEngine}
\writer{Anders, Albert}

The interface that described in Section~\ref{sec:3d-engine} will be implemented using jMonkey library. In the following, the implementation of the interface will be described.

\textbf{init(Geometry geometry, Appearance appearance)}
The initialization will put all information about the geometry and appearance into a list of SObjects. An SObject is a line segment, or using Petri Net terms: two transitions and a place. This list of SObjects is then used to set up the animations that will be playable in the simulation. The animations are created using the MotionPath and MotionEvent classes inherited from jMonkey. For each SObject, a MotionPath is created using the points that make up the line segement; this could be a beginning point, a few bend points and an end point. The MotionPath is then used to set up the MotionEvent, which besides needing a MotionPath, also needs some geometry, which in this case will be a shape defined by the SObject. The shape will be the shape of the token on the line segment. All tokens have need to be prepared as jMonkey geometries before creating the MotionEvents.

When all animations are set up in a list of MotionEvents, the paths will have their shape applied. This will make the Petri Net visible to the user. It will require stretching and duplication of the shapes and textures. Also, the camera will be positioned and oriented to its default position, and default background geometry will be created.

The simulator will produce a list of animations for jMonkey to play. Animations may be added to this list at any time. When animations finish, jMonkey will tell the simulator. This is the main interaction between the simulator and jMonkey. So when the system allows users to play, pause and reset the simulation, the play and pause will be handled by jMonkey alone. The simulator will need to know when the user resets the simulation, because it needs to tell the Petri Net engine to reset. But most of the time, the simulator will just wait for information about which animations have finished, and pass that on to the Petri Net engine, which in return will tell the simulator which animations jMonkey should play.

\textbf{onStart()}
The MotionEvent system used to set up the animations allows jMonkey to know the status of each animation. When the user opens the simulator, he will need to press play for the animation to begin. This action will cause jMonkey to run the animations that it was instructed to run by the simulator. If the user is pressing play, while the simulation was paused, jMonkey will simply continue playing all the paused MotionEvents.

\textbf{onPause()}
When the user presses pause, jMonkey will find the animations that are currently running, and pause them. The pause function is already integrated in the MotionEvent class.

\textbf{onReset()}
It the simulation is asked to reset, jMonkey will report to the simulator that it needs to reset the Petri Net engine. This is to ensure that the list of animations is correct.

\textbf{onUserClick()}
When a user clicks, a jMonkey listener will pick it up, and the position determined. If the click was on an input place, the name of the input place will be sent to the simulator, which will tell the Petri Net engine. The Petri Net engine will then determine how this affects the logic.

\textbf{animate(List<Animation> animations)}
The animations in the simulator are started according to the current list of animations waiting to be played. If the simulator is running, all animations arriving in the list of animations will be started instantly.

\textbf{onAnimationFinished(Animation animation)}
The simulator needs to know as soon as animations have finished, in order to quickly get the next animation. The state of all animations is checked 60 times per second, and the delay between one animation finishing and the next starting should be low.

\subsubsection{Collision Detection}
\writer{Thibaud}

The collision detection mechanism is straightforward in this simulation. Each time a token is destroyed or created in the Petri net engine, the 3D Engine does the same. Furthermore, each token has a unique ID defined with the help of an atomic counter to prevent concurrent access to the same ID. Since atomic operations take only one instruction of the CPU to execute, we guarantee the thread safety of this property.
This ID is then used by the simulator to implement the logic behind the collision detection.

First of all, we defined two hashmaps in our 3D Engine: allRenderedEvents (Key: token ID, Value: JMonkeyMove) and allCollisions (Key: token ID, Value: ArrayList of token IDs which collide with this token).
In the allRenderedEvents HashMap, we put each animation running in the simulation. 

In the SimpleUpdate loop of the application, we try to collide each spatial with all the other rendered spatials. If they collide, we compare their ids. By design, we know that the token who will need to stop is the one with the biggest ID, since it appeared later on the line. Therefore, we get a list of all tokens who collide with each token, pause all those "collided" tokens, and wait for the collisions to disappear. Once they don't collide anymore, we remove them from the allCollisions HashMap and we resume their animation.

Our 3D Engine doesn't support multi-line collisions yet. If we had a function that could return the progress of the MotionEvent, this would have been really easy (pausing the animations that have the smallest progress when animations collide). However, here, for simplicity, only tokens on the same line will have the opportunity to collide.