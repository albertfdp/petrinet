\subsection{The jMonkeyEngine}
\writer{Anders, Albert, Monica}

The interface that was described in Section~\ref{sec:3d-engine} will be implemented using the jMonkey library. In the following, the implementation of the engine will be described.

Apart from the methods inherited by implementing the Engine3D interface, jMonkeyEngine also inherits some features from the \textit{SimpleApplication} class, specific to the JMonkey library:

\textit{simpleInitApp()} - method which sets up general settings of the simulation window such as: 
\begin{enumerate}
\item the light
\item the environment (rendering of all the 3D objects according to the geometry and appearance files)
\item the bounding box
\item the ground
\item the animations (all possible animations received in the initialization)
\item the position of the camera
\item the key mappings (keys that will trigger a certain behavior when pressed by the user)   
\end{enumerate}  

 
\textit{simpleUpdate()} - called periodically while the simulation is running and verifies the current state of the engine in order to play/pause available animations and check for possible collision.

 
In order to make the 3D visualization possible, the following JMonkey classes have been used to model the predefined geometries and their corresponding appearances: 
\begin{itemize}
\item \textbf{Curve} - used to draw lines (tracks) in the 3D simulation based on a CatmullRom spline and the control points (connectors and bend points) from the geometry (see Section \ref{sec:arch-geometry}. 
\item \textbf{Geometry} - JMonkey object rendered in the simulation and seen by the user
\item \textbf{Material} - applied to JMonkey geometries for appearance details
\item \textbf{Texture} - set to the material according to the appearance file
\item \textbf{MotionPath} - creates a path along a series of control points (the same as for the curve)
\item \textbf{MotionEvent} - used for \textit{move} animations, requires a MotionPath and a Geometry (such an event will move the given geometry along the given path; e.g. move a train on a track)
\end{itemize}

All the curves, materials, textures, geometries, paths and all possible event will be prepared in the initialization phase, before the GUI start button is actually pressed, in order to improve the performance of the simulation at run time. 
This will make the Petri Net visible to the user. It will require stretching and duplication of the shapes and textures. Also, the camera will be positioned and oriented to its default position, and a default background geometry will be created.

All animations are set up in a hash map of ids and MotionEvents and played once the user has pressed the "Start" button. 
In the beginning, the simulator will provide an initial list of animations to be played. The play and pause actions are dealt with by JMonkey alone but, when an animation has finished, the Simulator is notified and, after receiving the next moves from the Petri net engine, will again provide the list of animations to be run by the 3D engine. 
This is the main interaction between the simulator and jMonkey. 

The buttons in the simulation window are implemented using \textbf{Nifty GUI}, a Java library well integrated with JMonkey and used for building interactive graphical user interfaces. Therefore, the buttons screen is overlaid on the JMonkey visualization and the buttons' screen layout is described in an XML file. The buttons actions are caught by the following two methods: 
\begin{itemize}
\item \textit{onStartButtonPressed()}
\item \textit{onResetButtonPressed()}
\end{itemize}
Moreover, all the other interactions of the user with the simulation window are handled with the implementation of an \textit{ActionListener}. 


\subsubsection{Collision Detection}
\writer{Thibaud}

The collision detection mechanism is straightforward in this simulation. Each time a token is destroyed or created in the Petri net engine, the 3D Engine does the same. Furthermore, each token has a unique ID defined with the help of an atomic counter to prevent concurrent access to the same ID. Since atomic operations take only one instruction of the CPU to execute, we guarantee the thread safety of this property.
This ID is then used by the simulator to implement the logic behind the collision detection.

First of all, we defined two hashmaps in our 3D Engine: allRenderedEvents (Key: token ID, Value: JMonkeyMove) and allCollisions (Key: token ID, Value: ArrayList of token IDs which collide with this token).
In the allRenderedEvents HashMap, we put each animation running in the simulation. 

In the SimpleUpdate loop of the application, we try to collide each spatial with all the other rendered spatials. If they collide, we compare their ids. By design, we know that the token who will need to stop is the one with the biggest ID, since it appeared later on the line. Therefore, we get a list of all tokens who collide with each token, pause all those "collided" tokens, and wait for the collisions to disappear. Once they don't collide anymore, we remove them from the allCollisions HashMap and we resume their animation.

Our 3D Engine doesn't support multi-line collisions yet. If we had a function that could return the progress of the MotionEvent, this would have been really easy (pausing the animations that have the smallest progress when animations collide). However, here, for simplicity, only tokens on the same line will have the opportunity to collide.