\subsection{The jMonkeyEngine}
\writer{Anders, Albert}

The interface that described in Section~\ref{sec:3d-engine} will be implemented using jMonkey library. In the following, the implementation of the interface will be described.

\textbf{init(Geometry geometry, Appearance appearance)}
The initialization will put all information about the geometry and appearance into a list of SObjects. An SObject is a line segment, or using Petri Net terms: two transitions and a place. This list of SObjects is then used to set up the animations that will be playable in the simulation. The animations are created using the MotionPath and MotionEvent classes inherited from jMonkey. For each SObject, a MotionPath is created using the points that make up the line segement; this could be a beginning point, a few bend points and an end point. The MotionPath is then used to set up the MotionEvent, which besides needing a MotionPath, also needs some geometry, which in this case will be a shape defined by the SObject. The shape will be the shape of the token on the line segment. All tokens have need to be prepared as jMonkey geometries before creating the MotionEvents.

When all animations are set up in a list of MotionEvents, the paths will have their shape applied. This will make the Petri Net visible to the user. It will require stretching and duplication of the shapes and textures. Also, the camera will be positioned and oriented to its default position, and default background geometry will be created.

The simulator will produce a list of animations for jMonkey to play. Animations may be added to this list at any time. When animations finish, jMonkey will tell the simulator. This is the main interaction between the simulator and jMonkey. So when the system allows users to play, pause and reset the simulation, the play and pause will be handled by jMonkey alone. The simulator will need to know when the user resets the simulation, because it needs to tell the Petri Net engine to reset. But most of the time, the simulator will just wait for information about which animations have finished, and pass that on to the Petri Net engine, which in return will tell the simulator which animations jMonkey should play.

\textbf{onStart()}
The MotionEvent system used to set up the animations allows jMonkey to know the status of each animation. When the user opens the simulator, he will need to press play for the animation to begin. This action will cause jMonkey to run the animations that it was instructed to run by the simulator. If the user is pressing play, while the simulation was paused, jMonkey will simply continue playing all the paused MotionEvents.

\textbf{onPause()}
When the user presses pause, jMonkey will find the animations that are currently running, and pause them. The pause function is already integrated in the MotionEvent class.

\textbf{onReset()}
It the simulation is asked to reset, jMonkey will report to the simulator that it needs to reset the Petri Net engine. This is to ensure that the list of animations is correct.

\textbf{onUserClick()}
When a user clicks, a jMonkey listener will pick it up, and the position determined. If the click was on an input place, the name of the input place will be sent to the simulator, which will tell the Petri Net engine. The Petri Net engine will then determine how this affects the logic.

\textbf{animate(List<Animation> animations)}
The animations in the simulator are started according to the current list of animations waiting to be played. If the simulator is running, all animations arriving in the list of animations will be started instantly.

\textbf{onAnimationFinished(Animation animation)}
The simulator needs to know as soon as animations have finished, in order to quickly get the next animation. The state of all animations is checked 60 times per second, and the delay between one animation finishing and the next starting should be low.

\subsubsection{Collision Detection}
\writer{Thibaud}